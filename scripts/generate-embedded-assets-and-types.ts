#!/usr/bin/env tsx

import { readFileSync, writeFileSync, existsSync, mkdirSync, readdirSync, statSync } from 'fs';
import path, { resolve, join, extname, relative } from 'path';
import { execSync } from 'child_process';
import { logger, toRelativePath } from './esbuild/colors';

/**
 * Enhanced script that dynamically generates both TypeScript modules for build-time
 * AND the .d.ts file with string literal types based on actual fish_files structure
 */

const projectRoot = process.cwd();
const tempAssetsDir = resolve(projectRoot, 'temp-embedded-assets');
const typesFile = resolve(projectRoot, 'src/types/embedded-assets.d.ts');

interface AssetPaths {
  fishFilesDir: string;
  wasmFile: string;
  coreTreeSitterWasmFile: string;
  manFile: string;
  buildTimeFile: string;
  packageJson: string;
}

interface FishFileInfo {
  fileName: string;
  relativePath: string;
  fullPath: string;
}

function ensureDir(dir: string): void {
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
}

function scanFishFiles(fishFilesDir: string): FishFileInfo[] {
  const files: FishFileInfo[] = [];

  if (!existsSync(fishFilesDir)) {
    console.warn(`Fish files directory not found: ${fishFilesDir}`);
    return files;
  }

  function scanDirectory(dir: string, relativePath = ''): void {
    const items = readdirSync(dir);

    for (const item of items) {
      const fullPath = join(dir, item);
      const stat = statSync(fullPath);
      const itemRelativePath = relativePath ? join(relativePath, item) : item;

      if (stat.isDirectory()) {
        scanDirectory(fullPath, itemRelativePath);
      } else if (stat.isFile() && extname(item) === '.fish') {
        files.push({
          fileName: item,
          relativePath: itemRelativePath,
          fullPath: fullPath
        });
      }
    }
  }

  scanDirectory(fishFilesDir);
  return files;
}

function generateDynamicTypeDefinitions(fishFiles: FishFileInfo[]): string {
  const header = `// Type declarations for embedded assets namespace
// These modules are handled by the esbuild embed-assets plugin
// This file is auto-generated by scripts/generate-embedded-assets-and-types.ts

`;

  const fishFileDeclarations = fishFiles.map(({ relativePath }) => {
    return `declare module '@embedded_assets/fish_files/${relativePath}' {
  const content: string;
  export default content;
}`;
  }).join('\n\n');

  const staticDeclarations = `
// Other embedded assets
declare module '@embedded_assets/tree-sitter-fish.wasm' {
  const wasmContent: string;
  export default wasmContent;
}

declare module '@embedded_assets/tree-sitter.wasm' {
  const wasmContent: string;
  export default wasmContent;
}

declare module '@embedded_assets/man/fish-lsp.1' {
  const manContent: string;
  export default manContent;
}

declare module '@embedded_assets/build-time.json' {
  const buildTime: any;
  export default buildTime;
}

declare module '@package' {
  const packageJson: any;
  export default packageJson;
}`;

  return header + fishFileDeclarations + staticDeclarations + '\n';
}

// Removed - no longer generating helper files

function generateTestSetupMocks(fishFiles: FishFileInfo[]): string {
  const existingImports = `import { vi } from 'vitest';
import { readFileSync } from 'fs';
import { resolve } from 'path';`;

  // Generate dynamic fish file mocks based on actual files
  const fishFileMocks = fishFiles.map(({ relativePath }) => {
    return `vi.mock('@embedded_assets/fish_files/${relativePath}', () => ({
  default: readFileSync(resolve(__dirname, '../fish_files/${relativePath}'), 'utf8'),
}));`;
  }).join('\n');

  const staticMocks = `

// Use actual WASM files for tree-sitter functionality in tests
vi.mock('@embedded_assets/tree-sitter-fish.wasm', () => ({
  default: readFileSync(resolve(__dirname, '../node_modules/@ndonfris/tree-sitter-fish/tree-sitter-fish.wasm')),
}));

vi.mock('@embedded_assets/tree-sitter.wasm', () => ({
  default: readFileSync(resolve(__dirname, '../node_modules/web-tree-sitter/tree-sitter.wasm')),
}));

// Mock fish file imports with actual file content
${fishFileMocks}

// Mock other assets
vi.mock('@embedded_assets/man/fish-lsp.1', () => ({
  default: readFileSync(resolve(__dirname, '../man/fish-lsp.1'), 'utf8'),
}));

// Use the actual build-time.json from the out directory
vi.mock('@embedded_assets/build-time.json', () => {
  try {
    return { default: JSON.parse(readFileSync(resolve(__dirname, '../out/build-time.json'), 'utf8')) };
  } catch (error) {
    // Fallback if build-time.json doesn't exist
    return { default: { buildTime: new Date().toISOString(), version: '1.0.0' } };
  }
});`;

  const pathMocks = `

// Mock path resolution functions to prevent incorrect file lookups in test environment
vi.mock('../src/utils/path-resolution', async () => {
  const actual = await vi.importActual('../src/utils/path-resolution') as any;
  return {
    ...actual,
    getFishBuildTimeFilePath: () => resolve(__dirname, '../out/build-time.json'),
    getProjectRootPath: () => resolve(__dirname, '..'),
    getTreeSitterWasmPath: () => resolve(__dirname, '../node_modules/@ndonfris/tree-sitter-fish/tree-sitter-fish.wasm'),
  };
});

// Mock process-env fish execution to prevent temp file errors in test environment
vi.mock('../src/utils/process-env', async () => {
  const actual = await vi.importActual('../src/utils/process-env') as any;
  return {
    ...actual,
    setupProcessEnvExecFile: vi.fn().mockResolvedValue(undefined),
    getProcessEnvFishPaths: vi.fn().mockResolvedValue({
      __fish_config_dir: '/home/user/.config/fish',
      __fish_data_dir: '/usr/share/fish',
      fish_function_path: '/home/user/.config/fish/functions:/usr/share/fish/functions',
      fish_complete_path: '/home/user/.config/fish/completions:/usr/share/fish/completions',
    }),
  };
});\n`;

  return `${existingImports}${staticMocks}${pathMocks}`;
}

function generateWasmModule(filePath: string, outputPath: string): void {
  if (!existsSync(filePath)) {
    writeFileSync(outputPath, 'const wasmContent: string = ""; export default wasmContent;');
    return;
  }

  const content = readFileSync(filePath);
  const base64 = content.toString('base64');
  const moduleContent = `const wasmContent: string = "data:application/wasm;base64,${base64}";
export default wasmContent;`;

  writeFileSync(outputPath, moduleContent);
}

function generateJsonModule(filePath: string, outputPath: string): void {
  if (!existsSync(filePath)) {
    writeFileSync(outputPath, 'const data: any = {}; export default data;');
    return;
  }

  const content = readFileSync(filePath, 'utf8');
  const json = JSON.parse(content);
  const moduleContent = `const data = ${JSON.stringify(json, null, 2)};
export default data;${filePath.includes('package.json') ? `
export const name: string = data.name;
export const version: string = data.version;` : ''}`;

  writeFileSync(outputPath, moduleContent);
}

function generateTextModule(filePath: string, outputPath: string): void {
  if (!existsSync(filePath)) {
    writeFileSync(outputPath, 'const content: string = ""; export default content;');
    return;
  }

  const content = readFileSync(filePath, 'utf8');
  const moduleContent = `const content: string = ${JSON.stringify(content)};
export default content;`;

  writeFileSync(outputPath, moduleContent);
}

export function generateEmbeddedAssetsTypesDynamic(): void {
  console.log(logger.building('embedded assets and test mocks'));

  execSync(`mkdir -p out && node scripts/build-time`, { stdio: 'ignore' });

  const assetPaths: AssetPaths = {
    fishFilesDir: resolve(projectRoot, 'fish_files'),
    wasmFile: resolve(projectRoot, 'node_modules/@ndonfris/tree-sitter-fish/tree-sitter-fish.wasm'),
    coreTreeSitterWasmFile: resolve(projectRoot, 'node_modules/web-tree-sitter/tree-sitter.wasm'),
    manFile: resolve(projectRoot, 'man', 'fish-lsp.1'),
    buildTimeFile: resolve(projectRoot, 'out', 'build-time.json'),
    packageJson: resolve(projectRoot, 'package.json'),
  };

  // 1. Scan fish files
  const fishFiles = scanFishFiles(assetPaths.fishFilesDir);
  console.log('  ' + logger.info(`Found ${fishFiles.length} fish files: ${logger.dim(fishFiles.map(f => f.relativePath).join(', '))}`));

  // 2. Generate dynamic type definitions
  const typeDefinitions = generateDynamicTypeDefinitions(fishFiles);
  writeFileSync(typesFile, typeDefinitions);
  console.log(logger.generated(typesFile));

  // 3. Generate and update tests/setup-mocks.ts
  const testMocks = generateTestSetupMocks(fishFiles);
  const testSetupPath = resolve(projectRoot, 'tests/setup-mocks.ts');
  writeFileSync(testSetupPath, testMocks);
  console.log(logger.generated(testSetupPath));

  // 4. Clean and create temp directory for build-time modules
  if (existsSync(tempAssetsDir)) {
    execSync(`rm -rf "${tempAssetsDir}"`, { stdio: 'pipe' });
  }
  ensureDir(tempAssetsDir);

  // 5. Generate WASM modules
  console.log([' ', 'Generating'.green, 'WASM'.blue, 'modules...'.green].join(' '));
  generateWasmModule(
    assetPaths.wasmFile,
    resolve(tempAssetsDir, 'tree-sitter-fish.wasm.ts')
  );

  generateWasmModule(
    assetPaths.coreTreeSitterWasmFile,
    resolve(tempAssetsDir, 'tree-sitter.wasm.ts')
  );

  // 6. Generate JSON modules
  console.log([' ', 'Generating'.green, 'JSON'.blue, 'modules...'.green].join(' '));
  generateJsonModule(
    assetPaths.packageJson,
    resolve(tempAssetsDir, 'package.json.ts')
  );

  generateJsonModule(
    assetPaths.buildTimeFile,
    resolve(tempAssetsDir, 'build-time.json.ts')
  );

  // 7. Generate man page module
  console.log([' ', 'Generating'.green, 'MAN PAGE'.blue, 'modules...'.green].join(' '));
  ensureDir(resolve(tempAssetsDir, 'man'));
  generateTextModule(
    assetPaths.manFile,
    resolve(tempAssetsDir, 'man', 'fish-lsp.1.ts')
  );

  // 8. Generate fish files modules dynamically
  // console.log(logger.info(`Generating ${fishFiles.length} fish file modules...`));
  console.log([' ', 'Generating'.green, fishFiles.length.toString().blue.bold, `fish file`.blue, 'modules...'.green].join(' '));
  const fishFilesDir = resolve(tempAssetsDir, 'fish_files');
  ensureDir(fishFilesDir);

  for (const fishFile of fishFiles) {
    const outputPath = resolve(fishFilesDir, fishFile.relativePath + '.ts');

    // Ensure nested directories exist
    ensureDir(resolve(outputPath, '..'));
    generateTextModule(fishFile.fullPath, outputPath);
  }

  // 9. Generate @package module (alias for package.json)
  // console.log(logger.info('Generating package alias module...'.red));
  console.log([' ', 'Generating'.green, `package.json alias`.blue, 'modules...'.green].join(' '));
  const packageModuleContent = `import pkg from './package.json';
export default pkg;`;
  writeFileSync(resolve(tempAssetsDir, 'package.ts'), packageModuleContent);

  console.log(`${' '} Generated embedded assets modules in ${relative(path.resolve(process.cwd()), tempAssetsDir)}`);
}

export function generateEmbeddedAssetsTypesAndMocks(): void {
  console.log(logger.header(' Dynamic Asset Generation'));
  generateEmbeddedAssetsTypesDynamic();
  console.log(logger.complete('embedded assets and test mocks'));
  // Clean up immediately - temp files only needed during generateTypeDeclarations()
}

export function generateEmbeddedAssetsTypesOnly(): void {
  console.log(logger.header('  Generating Types and Mocks Only'));
  execSync(`mkdir -p out && node scripts/build-time`, { stdio: ['ignore'], killSignal: 'SIGINT' });

  const assetPaths: AssetPaths = {
    fishFilesDir: resolve(projectRoot, 'fish_files'),
    wasmFile: resolve(projectRoot, 'node_modules/@ndonfris/tree-sitter-fish/tree-sitter-fish.wasm'),
    coreTreeSitterWasmFile: resolve(projectRoot, 'node_modules/web-tree-sitter/tree-sitter.wasm'),
    manFile: resolve(projectRoot, 'man', 'fish-lsp.1'),
    buildTimeFile: resolve(projectRoot, 'out', 'build-time.json'),
    packageJson: resolve(projectRoot, 'package.json'),
  };

  // 1. Scan fish files
  const fishFiles = scanFishFiles(assetPaths.fishFilesDir);
  console.log(logger.info(`${' '} Found ${fishFiles.length} fish files: ${logger.dim(fishFiles.map(f => f.relativePath).join(', '))}`));

  // 2. Generate dynamic type definitions
  const typeDefinitions = generateDynamicTypeDefinitions(fishFiles);
  writeFileSync(typesFile, typeDefinitions);
  console.log([' ', toRelativePath(typesFile)].join(' '));

  // 3. Generate and update tests/setup-mocks.ts
  const testMocks = generateTestSetupMocks(fishFiles);
  const testSetupPath = resolve(projectRoot, 'tests/setup-mocks.ts');
  writeFileSync(testSetupPath, testMocks);
  console.log(logger.generated(toRelativePath(testSetupPath)));

  console.log(logger.complete('types and mocks generation'));
}

export function cleanupEmbeddedAssetsTypes(): void {
  if (existsSync(tempAssetsDir)) {
    execSync(`rm -rf "${tempAssetsDir}"`, { stdio: 'inherit' });
  }
}

// Allow running as script
if (require.main === module) {
  // Check for command line args
  const args = process.argv.slice(2);
  const setupOnly = args.includes('--setup-only') || args.includes('--types-only');

  if (setupOnly) {
    generateEmbeddedAssetsTypesOnly();
  } else {
    generateEmbeddedAssetsTypesAndMocks();
  }
}
